# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/immich-app/immich/a07ae9b5b2dd8e747d1f620fdf5f5635277d5ee7/open-api/immich-openapi-specs.json
#   timestamp: 2025-01-24T02:00:28+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import List, Optional
from uuid import UUID

from pydantic import AnyUrl, BaseModel, EmailStr, Field, confloat, conint, constr


class APIKeyUpdateDto(BaseModel):
    name: str


class ActivityStatisticsResponseDto(BaseModel):
    comments: int


class AdminOnboardingUpdateDto(BaseModel):
    isOnboarded: bool


class AlbumStatisticsResponseDto(BaseModel):
    notShared: int
    owned: int
    shared: int


class AlbumUserRole(Enum):
    editor = "editor"
    viewer = "viewer"


class AssetBulkDeleteDto(BaseModel):
    force: Optional[bool] = None
    ids: List[UUID]


class AssetBulkUpdateDto(BaseModel):
    dateTimeOriginal: Optional[str] = None
    duplicateId: Optional[str] = None
    ids: List[UUID]
    isArchived: Optional[bool] = None
    isFavorite: Optional[bool] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    rating: Optional[confloat(ge=0.0, le=5.0)] = None


class AssetBulkUploadCheckItem(BaseModel):
    checksum: str = Field(..., description="base64 or hex encoded sha1 hash")
    id: str


class Action(Enum):
    accept = "accept"
    reject = "reject"


class Reason(Enum):
    duplicate = "duplicate"
    unsupported_format = "unsupported-format"


class AssetBulkUploadCheckResult(BaseModel):
    action: Action
    assetId: Optional[str] = None
    id: str
    isTrashed: Optional[bool] = None
    reason: Optional[Reason] = None


class AssetDeltaSyncDto(BaseModel):
    updatedAfter: datetime
    userIds: List[UUID]


class AssetFaceUpdateItem(BaseModel):
    assetId: UUID
    personId: UUID


class AssetFullSyncDto(BaseModel):
    lastId: Optional[UUID] = None
    limit: conint(ge=1)
    updatedUntil: datetime
    userId: Optional[UUID] = None


class AssetIdsDto(BaseModel):
    assetIds: List[UUID]


class Error(Enum):
    duplicate = "duplicate"
    no_permission = "no_permission"
    not_found = "not_found"


class AssetIdsResponseDto(BaseModel):
    assetId: str
    error: Optional[Error] = None
    success: bool


class AssetJobName(Enum):
    refresh_faces = "refresh-faces"
    refresh_metadata = "refresh-metadata"
    regenerate_thumbnail = "regenerate-thumbnail"
    transcode_video = "transcode-video"


class AssetJobsDto(BaseModel):
    assetIds: List[UUID]
    name: AssetJobName


class AssetMediaCreateDto(BaseModel):
    assetData: bytes
    deviceAssetId: str
    deviceId: str
    duration: Optional[str] = None
    fileCreatedAt: datetime
    fileModifiedAt: datetime
    isArchived: Optional[bool] = None
    isFavorite: Optional[bool] = None
    isVisible: Optional[bool] = None
    livePhotoVideoId: Optional[UUID] = None
    sidecarData: Optional[bytes] = None


class AssetMediaReplaceDto(BaseModel):
    assetData: bytes
    deviceAssetId: str
    deviceId: str
    duration: Optional[str] = None
    fileCreatedAt: datetime
    fileModifiedAt: datetime


class AssetMediaSize(Enum):
    preview = "preview"
    thumbnail = "thumbnail"


class AssetMediaStatus(Enum):
    created = "created"
    replaced = "replaced"
    duplicate = "duplicate"


class AssetOrder(Enum):
    asc = "asc"
    desc = "desc"


class AssetStackResponseDto(BaseModel):
    assetCount: int
    id: str
    primaryAssetId: str


class AssetStatsResponseDto(BaseModel):
    images: int
    total: int
    videos: int


class AssetTypeEnum(Enum):
    IMAGE = "IMAGE"
    VIDEO = "VIDEO"
    AUDIO = "AUDIO"
    OTHER = "OTHER"


class AudioCodec(Enum):
    mp3 = "mp3"
    aac = "aac"
    libopus = "libopus"
    pcm_s16le = "pcm_s16le"


class AuditDeletesResponseDto(BaseModel):
    ids: List[str]
    needsFullSync: bool


class Error1(Enum):
    duplicate = "duplicate"
    no_permission = "no_permission"
    not_found = "not_found"
    unknown = "unknown"


class BulkIdResponseDto(BaseModel):
    error: Optional[Error1] = None
    id: str
    success: bool


class BulkIdsDto(BaseModel):
    ids: List[UUID]


class CLIPConfig(BaseModel):
    enabled: bool
    modelName: str


class CQMode(Enum):
    auto = "auto"
    cqp = "cqp"
    icq = "icq"


class ChangePasswordDto(BaseModel):
    newPassword: constr(min_length=8) = Field(..., examples=["password"])
    password: str = Field(..., examples=["password"])


class CheckExistingAssetsDto(BaseModel):
    deviceAssetIds: List[str] = Field(..., min_length=1)
    deviceId: str


class CheckExistingAssetsResponseDto(BaseModel):
    existingIds: List[str]


class Colorspace(Enum):
    srgb = "srgb"
    p3 = "p3"


class CreateLibraryDto(BaseModel):
    exclusionPatterns: Optional[List[str]] = Field(None, max_length=128)
    importPaths: Optional[List[str]] = Field(None, max_length=128)
    name: Optional[str] = None
    ownerId: UUID


class CreateProfileImageDto(BaseModel):
    file: bytes


class CreateProfileImageResponseDto(BaseModel):
    profileChangedAt: datetime
    profileImagePath: str
    userId: str


class DatabaseBackupConfig(BaseModel):
    cronExpression: str
    enabled: bool
    keepLastAmount: confloat(ge=1.0)


class DownloadArchiveInfo(BaseModel):
    assetIds: List[str]
    size: int


class DownloadInfoDto(BaseModel):
    albumId: Optional[UUID] = None
    archiveSize: Optional[conint(ge=1)] = None
    assetIds: Optional[List[UUID]] = None
    userId: Optional[UUID] = None


class DownloadResponse(BaseModel):
    archiveSize: int
    includeEmbeddedVideos: bool


class DownloadResponseDto(BaseModel):
    archives: List[DownloadArchiveInfo]
    totalSize: int


class DownloadUpdate(BaseModel):
    archiveSize: Optional[conint(ge=1)] = None
    includeEmbeddedVideos: Optional[bool] = None


class DuplicateDetectionConfig(BaseModel):
    enabled: bool
    maxDistance: confloat(ge=0.001, le=0.1)


class EmailNotificationsResponse(BaseModel):
    albumInvite: bool
    albumUpdate: bool
    enabled: bool


class EmailNotificationsUpdate(BaseModel):
    albumInvite: Optional[bool] = None
    albumUpdate: Optional[bool] = None
    enabled: Optional[bool] = None


class EntityType(Enum):
    ASSET = "ASSET"
    ALBUM = "ALBUM"


class ExifResponseDto(BaseModel):
    city: Optional[str] = None
    country: Optional[str] = None
    dateTimeOriginal: Optional[datetime] = None
    description: Optional[str] = None
    exifImageHeight: Optional[float] = None
    exifImageWidth: Optional[float] = None
    exposureTime: Optional[str] = None
    fNumber: Optional[float] = None
    fileSizeInByte: Optional[int] = None
    focalLength: Optional[float] = None
    iso: Optional[float] = None
    latitude: Optional[float] = None
    lensModel: Optional[str] = None
    longitude: Optional[float] = None
    make: Optional[str] = None
    model: Optional[str] = None
    modifyDate: Optional[datetime] = None
    orientation: Optional[str] = None
    projectionType: Optional[str] = None
    rating: Optional[float] = None
    state: Optional[str] = None
    timeZone: Optional[str] = None


class FaceDto(BaseModel):
    id: UUID


class FacialRecognitionConfig(BaseModel):
    enabled: bool
    maxDistance: confloat(ge=0.1, le=2.0)
    minFaces: conint(ge=1)
    minScore: confloat(ge=0.1, le=1.0)
    modelName: str


class FileChecksumDto(BaseModel):
    filenames: List[str]


class FileChecksumResponseDto(BaseModel):
    checksum: str
    filename: str


class FoldersResponse(BaseModel):
    enabled: bool
    sidebarWeb: bool


class FoldersUpdate(BaseModel):
    enabled: Optional[bool] = None
    sidebarWeb: Optional[bool] = None


class ImageFormat(Enum):
    jpeg = "jpeg"
    webp = "webp"


class JobCommand(Enum):
    start = "start"
    pause = "pause"
    resume = "resume"
    empty = "empty"
    clear_failed = "clear-failed"


class JobCommandDto(BaseModel):
    command: JobCommand
    force: Optional[bool] = None


class JobCountsDto(BaseModel):
    active: int
    completed: int
    delayed: int
    failed: int
    paused: int
    waiting: int


class JobName(Enum):
    thumbnailGeneration = "thumbnailGeneration"
    metadataExtraction = "metadataExtraction"
    videoConversion = "videoConversion"
    faceDetection = "faceDetection"
    facialRecognition = "facialRecognition"
    smartSearch = "smartSearch"
    duplicateDetection = "duplicateDetection"
    backgroundTask = "backgroundTask"
    storageTemplateMigration = "storageTemplateMigration"
    migration = "migration"
    search = "search"
    sidecar = "sidecar"
    library = "library"
    notifications = "notifications"
    backupDatabase = "backupDatabase"


class JobSettingsDto(BaseModel):
    concurrency: conint(ge=1)


class LibraryResponseDto(BaseModel):
    assetCount: int
    createdAt: datetime
    exclusionPatterns: List[str]
    id: str
    importPaths: List[str]
    name: str
    ownerId: str
    refreshedAt: datetime
    updatedAt: datetime


class LibraryStatsResponseDto(BaseModel):
    photos: int
    total: int
    usage: int
    videos: int


class LicenseKeyDto(BaseModel):
    activationKey: str
    licenseKey: constr(pattern=r"/IM(SV|CL)(-[\dA-Za-z]{4}){8}/")


class LicenseResponseDto(BaseModel):
    activatedAt: datetime
    activationKey: str
    licenseKey: constr(pattern=r"/IM(SV|CL)(-[\dA-Za-z]{4}){8}/")


class LogLevel(Enum):
    verbose = "verbose"
    debug = "debug"
    log = "log"
    warn = "warn"
    error = "error"
    fatal = "fatal"


class LoginCredentialDto(BaseModel):
    email: EmailStr = Field(..., examples=["testuser@email.com"])
    password: str = Field(..., examples=["password"])


class LoginResponseDto(BaseModel):
    accessToken: str
    isAdmin: bool
    name: str
    profileImagePath: str
    shouldChangePassword: bool
    userEmail: str
    userId: str


class LogoutResponseDto(BaseModel):
    redirectUri: str
    successful: bool


class ManualJobName(Enum):
    person_cleanup = "person-cleanup"
    tag_cleanup = "tag-cleanup"
    user_cleanup = "user-cleanup"


class MapMarkerResponseDto(BaseModel):
    city: str
    country: str
    id: str
    lat: float
    lon: float
    state: str


class MapReverseGeocodeResponseDto(BaseModel):
    city: str
    country: str
    state: str


class MemoriesResponse(BaseModel):
    enabled: bool


class MemoriesUpdate(BaseModel):
    enabled: Optional[bool] = None


class MemoryType(Enum):
    on_this_day = "on_this_day"


class MemoryUpdateDto(BaseModel):
    isSaved: Optional[bool] = None
    memoryAt: Optional[datetime] = None
    seenAt: Optional[datetime] = None


class MergePersonDto(BaseModel):
    ids: List[UUID]


class MetadataSearchDto(BaseModel):
    checksum: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    createdAfter: Optional[datetime] = None
    createdBefore: Optional[datetime] = None
    deviceAssetId: Optional[str] = None
    deviceId: Optional[str] = None
    encodedVideoPath: Optional[str] = None
    id: Optional[UUID] = None
    isArchived: Optional[bool] = None
    isEncoded: Optional[bool] = None
    isFavorite: Optional[bool] = None
    isMotion: Optional[bool] = None
    isNotInAlbum: Optional[bool] = None
    isOffline: Optional[bool] = None
    isVisible: Optional[bool] = None
    lensModel: Optional[str] = None
    libraryId: Optional[UUID] = None
    make: Optional[str] = None
    model: Optional[str] = None
    order: Optional[AssetOrder] = "desc"
    originalFileName: Optional[str] = None
    originalPath: Optional[str] = None
    page: Optional[confloat(ge=1.0)] = None
    personIds: Optional[List[UUID]] = None
    previewPath: Optional[str] = None
    size: Optional[confloat(ge=1.0, le=1000.0)] = None
    state: Optional[str] = None
    takenAfter: Optional[datetime] = None
    takenBefore: Optional[datetime] = None
    thumbnailPath: Optional[str] = None
    trashedAfter: Optional[datetime] = None
    trashedBefore: Optional[datetime] = None
    type: Optional[AssetTypeEnum] = None
    updatedAfter: Optional[datetime] = None
    updatedBefore: Optional[datetime] = None
    withArchived: Optional[bool] = False
    withDeleted: Optional[bool] = None
    withExif: Optional[bool] = None
    withPeople: Optional[bool] = None
    withStacked: Optional[bool] = None


class OAuthAuthorizeResponseDto(BaseModel):
    url: str


class OAuthCallbackDto(BaseModel):
    url: str


class OAuthConfigDto(BaseModel):
    redirectUri: str


class OnThisDayDto(BaseModel):
    year: confloat(ge=1.0)


class PartnerDirection(Enum):
    shared_by = "shared-by"
    shared_with = "shared-with"


class PathEntityType(Enum):
    asset = "asset"
    person = "person"
    user = "user"


class PathType(Enum):
    original = "original"
    preview = "preview"
    thumbnail = "thumbnail"
    encoded_video = "encoded_video"
    sidecar = "sidecar"
    face = "face"
    profile = "profile"


class PeopleResponse(BaseModel):
    enabled: bool
    sidebarWeb: bool


class PeopleUpdate(BaseModel):
    enabled: Optional[bool] = None
    sidebarWeb: Optional[bool] = None


class PeopleUpdateItem(BaseModel):
    birthDate: Optional[date] = Field(
        None,
        description="Person date of birth.\nNote: the mobile app cannot currently set the birth date to null.",
    )
    featureFaceAssetId: Optional[str] = Field(
        None, description="Asset is used to get the feature face thumbnail."
    )
    id: str = Field(..., description="Person id.")
    isHidden: Optional[bool] = Field(None, description="Person visibility")
    name: Optional[str] = Field(None, description="Person name.")


class Permission(Enum):
    all = "all"
    activity_create = "activity.create"
    activity_read = "activity.read"
    activity_update = "activity.update"
    activity_delete = "activity.delete"
    activity_statistics = "activity.statistics"
    apiKey_create = "apiKey.create"
    apiKey_read = "apiKey.read"
    apiKey_update = "apiKey.update"
    apiKey_delete = "apiKey.delete"
    asset_read = "asset.read"
    asset_update = "asset.update"
    asset_delete = "asset.delete"
    asset_share = "asset.share"
    asset_view = "asset.view"
    asset_download = "asset.download"
    asset_upload = "asset.upload"
    album_create = "album.create"
    album_read = "album.read"
    album_update = "album.update"
    album_delete = "album.delete"
    album_statistics = "album.statistics"
    album_addAsset = "album.addAsset"
    album_removeAsset = "album.removeAsset"
    album_share = "album.share"
    album_download = "album.download"
    authDevice_delete = "authDevice.delete"
    archive_read = "archive.read"
    face_create = "face.create"
    face_read = "face.read"
    face_update = "face.update"
    face_delete = "face.delete"
    library_create = "library.create"
    library_read = "library.read"
    library_update = "library.update"
    library_delete = "library.delete"
    library_statistics = "library.statistics"
    timeline_read = "timeline.read"
    timeline_download = "timeline.download"
    memory_create = "memory.create"
    memory_read = "memory.read"
    memory_update = "memory.update"
    memory_delete = "memory.delete"
    partner_create = "partner.create"
    partner_read = "partner.read"
    partner_update = "partner.update"
    partner_delete = "partner.delete"
    person_create = "person.create"
    person_read = "person.read"
    person_update = "person.update"
    person_delete = "person.delete"
    person_statistics = "person.statistics"
    person_merge = "person.merge"
    person_reassign = "person.reassign"
    session_read = "session.read"
    session_update = "session.update"
    session_delete = "session.delete"
    sharedLink_create = "sharedLink.create"
    sharedLink_read = "sharedLink.read"
    sharedLink_update = "sharedLink.update"
    sharedLink_delete = "sharedLink.delete"
    stack_create = "stack.create"
    stack_read = "stack.read"
    stack_update = "stack.update"
    stack_delete = "stack.delete"
    systemConfig_read = "systemConfig.read"
    systemConfig_update = "systemConfig.update"
    systemMetadata_read = "systemMetadata.read"
    systemMetadata_update = "systemMetadata.update"
    tag_create = "tag.create"
    tag_read = "tag.read"
    tag_update = "tag.update"
    tag_delete = "tag.delete"
    tag_asset = "tag.asset"
    admin_user_create = "admin.user.create"
    admin_user_read = "admin.user.read"
    admin_user_update = "admin.user.update"
    admin_user_delete = "admin.user.delete"


class PersonCreateDto(BaseModel):
    birthDate: Optional[date] = Field(
        None,
        description="Person date of birth.\nNote: the mobile app cannot currently set the birth date to null.",
    )
    isHidden: Optional[bool] = Field(None, description="Person visibility")
    name: Optional[str] = Field(None, description="Person name.")


class PersonResponseDto(BaseModel):
    birthDate: date
    id: str
    isHidden: bool
    name: str
    thumbnailPath: str
    updatedAt: Optional[datetime] = Field(
        None, description="This property was added in v1.107.0"
    )


class PersonStatisticsResponseDto(BaseModel):
    assets: int


class PersonUpdateDto(BaseModel):
    birthDate: Optional[date] = Field(
        None,
        description="Person date of birth.\nNote: the mobile app cannot currently set the birth date to null.",
    )
    featureFaceAssetId: Optional[str] = Field(
        None, description="Asset is used to get the feature face thumbnail."
    )
    isHidden: Optional[bool] = Field(None, description="Person visibility")
    name: Optional[str] = Field(None, description="Person name.")


class PlacesResponseDto(BaseModel):
    admin1name: Optional[str] = None
    admin2name: Optional[str] = None
    latitude: float
    longitude: float
    name: str


class PurchaseResponse(BaseModel):
    hideBuyButtonUntil: str
    showSupportBadge: bool


class PurchaseUpdate(BaseModel):
    hideBuyButtonUntil: Optional[str] = None
    showSupportBadge: Optional[bool] = None


class QueueStatusDto(BaseModel):
    isActive: bool
    isPaused: bool


class RandomSearchDto(BaseModel):
    city: Optional[str] = None
    country: Optional[str] = None
    createdAfter: Optional[datetime] = None
    createdBefore: Optional[datetime] = None
    deviceId: Optional[str] = None
    isArchived: Optional[bool] = None
    isEncoded: Optional[bool] = None
    isFavorite: Optional[bool] = None
    isMotion: Optional[bool] = None
    isNotInAlbum: Optional[bool] = None
    isOffline: Optional[bool] = None
    isVisible: Optional[bool] = None
    lensModel: Optional[str] = None
    libraryId: Optional[UUID] = None
    make: Optional[str] = None
    model: Optional[str] = None
    personIds: Optional[List[UUID]] = None
    size: Optional[confloat(ge=1.0, le=1000.0)] = None
    state: Optional[str] = None
    takenAfter: Optional[datetime] = None
    takenBefore: Optional[datetime] = None
    trashedAfter: Optional[datetime] = None
    trashedBefore: Optional[datetime] = None
    type: Optional[AssetTypeEnum] = None
    updatedAfter: Optional[datetime] = None
    updatedBefore: Optional[datetime] = None
    withArchived: Optional[bool] = False
    withDeleted: Optional[bool] = None
    withExif: Optional[bool] = None
    withPeople: Optional[bool] = None
    withStacked: Optional[bool] = None


class RatingsResponse(BaseModel):
    enabled: bool


class RatingsUpdate(BaseModel):
    enabled: Optional[bool] = None


class ReactionLevel(Enum):
    album = "album"
    asset = "asset"


class ReactionType(Enum):
    comment = "comment"
    like = "like"


class ReverseGeocodingStateResponseDto(BaseModel):
    lastImportFileName: str
    lastUpdate: str


class SearchFacetCountResponseDto(BaseModel):
    count: int
    value: str


class SearchFacetResponseDto(BaseModel):
    counts: List[SearchFacetCountResponseDto]
    fieldName: str


class SearchSuggestionType(Enum):
    country = "country"
    state = "state"
    city = "city"
    camera_make = "camera-make"
    camera_model = "camera-model"


class ServerAboutResponseDto(BaseModel):
    build: Optional[str] = None
    buildImage: Optional[str] = None
    buildImageUrl: Optional[str] = None
    buildUrl: Optional[str] = None
    exiftool: Optional[str] = None
    ffmpeg: Optional[str] = None
    imagemagick: Optional[str] = None
    libvips: Optional[str] = None
    licensed: bool
    nodejs: Optional[str] = None
    repository: Optional[str] = None
    repositoryUrl: Optional[str] = None
    sourceCommit: Optional[str] = None
    sourceRef: Optional[str] = None
    sourceUrl: Optional[str] = None
    thirdPartyBugFeatureUrl: Optional[str] = None
    thirdPartyDocumentationUrl: Optional[str] = None
    thirdPartySourceUrl: Optional[str] = None
    thirdPartySupportUrl: Optional[str] = None
    version: str
    versionUrl: str


class ServerConfigDto(BaseModel):
    externalDomain: str
    isInitialized: bool
    isOnboarded: bool
    loginPageMessage: str
    mapDarkStyleUrl: str
    mapLightStyleUrl: str
    oauthButtonText: str
    publicUsers: bool
    trashDays: int
    userDeleteDelay: int


class ServerFeaturesDto(BaseModel):
    configFile: bool
    duplicateDetection: bool
    email: bool
    facialRecognition: bool
    importFaces: bool
    map: bool
    oauth: bool
    oauthAutoLaunch: bool
    passwordLogin: bool
    reverseGeocoding: bool
    search: bool
    sidecar: bool
    smartSearch: bool
    trash: bool


class ServerMediaTypesResponseDto(BaseModel):
    image: List[str]
    sidecar: List[str]
    video: List[str]


class ServerPingResponse(BaseModel):
    res: str = Field(..., examples=["pong"])


class ServerStorageResponseDto(BaseModel):
    diskAvailable: str
    diskAvailableRaw: int
    diskSize: str
    diskSizeRaw: int
    diskUsagePercentage: float
    diskUse: str
    diskUseRaw: int


class ServerThemeDto(BaseModel):
    customCss: str


class ServerVersionHistoryResponseDto(BaseModel):
    createdAt: datetime
    id: str
    version: str


class ServerVersionResponseDto(BaseModel):
    major: int
    minor: int
    patch: int


class SessionResponseDto(BaseModel):
    createdAt: str
    current: bool
    deviceOS: str
    deviceType: str
    id: str
    updatedAt: str


class SharedLinkEditDto(BaseModel):
    allowDownload: Optional[bool] = None
    allowUpload: Optional[bool] = None
    changeExpiryTime: Optional[bool] = Field(
        None,
        description="Few clients cannot send null to set the expiryTime to never.\nSetting this flag and not sending expiryAt is considered as null instead.\nClients that can send null values can ignore this.",
    )
    description: Optional[str] = None
    expiresAt: Optional[datetime] = None
    password: Optional[str] = None
    showMetadata: Optional[bool] = None


class SharedLinkType(Enum):
    ALBUM = "ALBUM"
    INDIVIDUAL = "INDIVIDUAL"


class SignUpDto(BaseModel):
    email: EmailStr = Field(..., examples=["testuser@email.com"])
    name: str = Field(..., examples=["Admin"])
    password: str = Field(..., examples=["password"])


class SmartSearchDto(BaseModel):
    city: Optional[str] = None
    country: Optional[str] = None
    createdAfter: Optional[datetime] = None
    createdBefore: Optional[datetime] = None
    deviceId: Optional[str] = None
    isArchived: Optional[bool] = None
    isEncoded: Optional[bool] = None
    isFavorite: Optional[bool] = None
    isMotion: Optional[bool] = None
    isNotInAlbum: Optional[bool] = None
    isOffline: Optional[bool] = None
    isVisible: Optional[bool] = None
    lensModel: Optional[str] = None
    libraryId: Optional[UUID] = None
    make: Optional[str] = None
    model: Optional[str] = None
    page: Optional[confloat(ge=1.0)] = None
    personIds: Optional[List[UUID]] = None
    query: str
    size: Optional[confloat(ge=1.0, le=1000.0)] = None
    state: Optional[str] = None
    takenAfter: Optional[datetime] = None
    takenBefore: Optional[datetime] = None
    trashedAfter: Optional[datetime] = None
    trashedBefore: Optional[datetime] = None
    type: Optional[AssetTypeEnum] = None
    updatedAfter: Optional[datetime] = None
    updatedBefore: Optional[datetime] = None
    withArchived: Optional[bool] = False
    withDeleted: Optional[bool] = None
    withExif: Optional[bool] = None


class SourceType(Enum):
    machine_learning = "machine-learning"
    exif = "exif"


class StackCreateDto(BaseModel):
    assetIds: List[UUID] = Field(
        ..., description="first asset becomes the primary", min_length=2
    )


class StackUpdateDto(BaseModel):
    primaryAssetId: Optional[UUID] = None


class SystemConfigBackupsDto(BaseModel):
    database: DatabaseBackupConfig


class SystemConfigFacesDto(BaseModel):
    import_: bool = Field(..., alias="import")


class SystemConfigGeneratedImageDto(BaseModel):
    format: ImageFormat
    quality: conint(ge=1, le=100)
    size: conint(ge=1)


class SystemConfigImageDto(BaseModel):
    colorspace: Colorspace
    extractEmbedded: bool
    preview: SystemConfigGeneratedImageDto
    thumbnail: SystemConfigGeneratedImageDto


class SystemConfigJobDto(BaseModel):
    backgroundTask: JobSettingsDto
    faceDetection: JobSettingsDto
    library: JobSettingsDto
    metadataExtraction: JobSettingsDto
    migration: JobSettingsDto
    notifications: JobSettingsDto
    search: JobSettingsDto
    sidecar: JobSettingsDto
    smartSearch: JobSettingsDto
    thumbnailGeneration: JobSettingsDto
    videoConversion: JobSettingsDto


class SystemConfigLibraryScanDto(BaseModel):
    cronExpression: str
    enabled: bool


class SystemConfigLibraryWatchDto(BaseModel):
    enabled: bool


class SystemConfigLoggingDto(BaseModel):
    enabled: bool
    level: LogLevel


class SystemConfigMachineLearningDto(BaseModel):
    clip: CLIPConfig
    duplicateDetection: DuplicateDetectionConfig
    enabled: bool
    facialRecognition: FacialRecognitionConfig
    url: Optional[str] = Field(
        None, description="This property was deprecated in v1.122.0"
    )
    urls: List[AnyUrl]


class SystemConfigMapDto(BaseModel):
    darkStyle: AnyUrl
    enabled: bool
    lightStyle: AnyUrl


class SystemConfigMetadataDto(BaseModel):
    faces: SystemConfigFacesDto


class SystemConfigNewVersionCheckDto(BaseModel):
    enabled: bool


class SystemConfigOAuthDto(BaseModel):
    autoLaunch: bool
    autoRegister: bool
    buttonText: str
    clientId: str
    clientSecret: str
    defaultStorageQuota: confloat(ge=0.0)
    enabled: bool
    issuerUrl: str
    mobileOverrideEnabled: bool
    mobileRedirectUri: AnyUrl
    profileSigningAlgorithm: str
    scope: str
    signingAlgorithm: str
    storageLabelClaim: str
    storageQuotaClaim: str


class SystemConfigPasswordLoginDto(BaseModel):
    enabled: bool


class SystemConfigReverseGeocodingDto(BaseModel):
    enabled: bool


class SystemConfigServerDto(BaseModel):
    externalDomain: AnyUrl
    loginPageMessage: str
    publicUsers: bool


class SystemConfigSmtpTransportDto(BaseModel):
    host: str
    ignoreCert: bool
    password: str
    port: confloat(ge=0.0, le=65535.0)
    username: str


class SystemConfigStorageTemplateDto(BaseModel):
    enabled: bool
    hashVerificationEnabled: bool
    template: str


class SystemConfigTemplateEmailsDto(BaseModel):
    albumInviteTemplate: str
    albumUpdateTemplate: str
    welcomeTemplate: str


class SystemConfigTemplateStorageOptionDto(BaseModel):
    dayOptions: List[str]
    hourOptions: List[str]
    minuteOptions: List[str]
    monthOptions: List[str]
    presetOptions: List[str]
    secondOptions: List[str]
    weekOptions: List[str]
    yearOptions: List[str]


class SystemConfigTemplatesDto(BaseModel):
    email: SystemConfigTemplateEmailsDto


class SystemConfigThemeDto(BaseModel):
    customCss: str


class SystemConfigTrashDto(BaseModel):
    days: conint(ge=0)
    enabled: bool


class SystemConfigUserDto(BaseModel):
    deleteDelay: conint(ge=1)


class TagBulkAssetsDto(BaseModel):
    assetIds: List[UUID]
    tagIds: List[UUID]


class TagBulkAssetsResponseDto(BaseModel):
    count: int


class TagCreateDto(BaseModel):
    color: Optional[
        constr(pattern=r"^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$")
    ] = None
    name: str
    parentId: Optional[UUID] = None


class TagResponseDto(BaseModel):
    color: Optional[str] = None
    createdAt: datetime
    id: str
    name: str
    parentId: Optional[str] = None
    updatedAt: datetime
    value: str


class TagUpdateDto(BaseModel):
    color: Optional[
        constr(pattern=r"^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$")
    ] = None


class TagUpsertDto(BaseModel):
    tags: List[str]


class TagsResponse(BaseModel):
    enabled: bool
    sidebarWeb: bool


class TagsUpdate(BaseModel):
    enabled: Optional[bool] = None
    sidebarWeb: Optional[bool] = None


class TemplateDto(BaseModel):
    template: str


class TemplateResponseDto(BaseModel):
    html: str
    name: str


class TestEmailResponseDto(BaseModel):
    messageId: str


class TimeBucketResponseDto(BaseModel):
    count: int
    timeBucket: str


class TimeBucketSize(Enum):
    DAY = "DAY"
    MONTH = "MONTH"


class ToneMapping(Enum):
    hable = "hable"
    mobius = "mobius"
    reinhard = "reinhard"
    disabled = "disabled"


class TranscodeHWAccel(Enum):
    nvenc = "nvenc"
    qsv = "qsv"
    vaapi = "vaapi"
    rkmpp = "rkmpp"
    disabled = "disabled"


class TranscodePolicy(Enum):
    all = "all"
    optimal = "optimal"
    bitrate = "bitrate"
    required = "required"
    disabled = "disabled"


class TrashResponseDto(BaseModel):
    count: int


class UpdateAlbumDto(BaseModel):
    albumName: Optional[str] = None
    albumThumbnailAssetId: Optional[UUID] = None
    description: Optional[str] = None
    isActivityEnabled: Optional[bool] = None
    order: Optional[AssetOrder] = None


class UpdateAlbumUserDto(BaseModel):
    role: AlbumUserRole


class UpdateAssetDto(BaseModel):
    dateTimeOriginal: Optional[str] = None
    description: Optional[str] = None
    isArchived: Optional[bool] = None
    isFavorite: Optional[bool] = None
    latitude: Optional[float] = None
    livePhotoVideoId: Optional[UUID] = None
    longitude: Optional[float] = None
    rating: Optional[confloat(ge=0.0, le=5.0)] = None


class UpdateLibraryDto(BaseModel):
    exclusionPatterns: Optional[List[str]] = Field(None, max_length=128)
    importPaths: Optional[List[str]] = Field(None, max_length=128)
    name: Optional[str] = None


class UpdatePartnerDto(BaseModel):
    inTimeline: bool


class UsageByUserDto(BaseModel):
    photos: int
    quotaSizeInBytes: int
    usage: int
    usagePhotos: int
    usageVideos: int
    userId: str
    userName: str
    videos: int


class UserAdminCreateDto(BaseModel):
    email: EmailStr
    name: str
    notify: Optional[bool] = None
    password: str
    quotaSizeInBytes: Optional[conint(ge=1)] = None
    shouldChangePassword: Optional[bool] = None
    storageLabel: Optional[str] = None


class UserAdminDeleteDto(BaseModel):
    force: Optional[bool] = None


class UserAdminUpdateDto(BaseModel):
    email: Optional[EmailStr] = None
    name: Optional[str] = None
    password: Optional[str] = None
    quotaSizeInBytes: Optional[conint(ge=1)] = None
    shouldChangePassword: Optional[bool] = None
    storageLabel: Optional[str] = None


class UserAvatarColor(Enum):
    primary = "primary"
    pink = "pink"
    red = "red"
    yellow = "yellow"
    blue = "blue"
    green = "green"
    purple = "purple"
    orange = "orange"
    gray = "gray"
    amber = "amber"


class UserLicense(BaseModel):
    activatedAt: datetime
    activationKey: str
    licenseKey: str


class UserResponseDto(BaseModel):
    avatarColor: UserAvatarColor
    email: str
    id: str
    name: str
    profileChangedAt: datetime
    profileImagePath: str


class UserStatus(Enum):
    active = "active"
    removing = "removing"
    deleted = "deleted"


class UserUpdateMeDto(BaseModel):
    email: Optional[EmailStr] = None
    name: Optional[str] = None
    password: Optional[str] = None


class ValidateAccessTokenResponseDto(BaseModel):
    authStatus: bool


class ValidateLibraryDto(BaseModel):
    exclusionPatterns: Optional[List[str]] = Field(None, max_length=128)
    importPaths: Optional[List[str]] = Field(None, max_length=128)


class ValidateLibraryImportPathResponseDto(BaseModel):
    importPath: str
    isValid: bool
    message: Optional[str] = None


class ValidateLibraryResponseDto(BaseModel):
    importPaths: Optional[List[ValidateLibraryImportPathResponseDto]] = None


class VideoCodec(Enum):
    h264 = "h264"
    hevc = "hevc"
    vp9 = "vp9"
    av1 = "av1"


class VideoContainer(Enum):
    mov = "mov"
    mp4 = "mp4"
    ogg = "ogg"
    webm = "webm"


class APIKeyCreateDto(BaseModel):
    name: Optional[str] = None
    permissions: List[Permission] = Field(..., min_length=1)


class APIKeyResponseDto(BaseModel):
    createdAt: datetime
    id: str
    name: str
    permissions: List[Permission]
    updatedAt: datetime


class ActivityCreateDto(BaseModel):
    albumId: UUID
    assetId: Optional[UUID] = None
    comment: Optional[str] = None
    type: ReactionType


class ActivityResponseDto(BaseModel):
    assetId: str
    comment: Optional[str] = None
    createdAt: datetime
    id: str
    type: ReactionType
    user: UserResponseDto


class AlbumUserAddDto(BaseModel):
    role: Optional[AlbumUserRole] = "editor"
    userId: UUID


class AlbumUserCreateDto(BaseModel):
    role: AlbumUserRole
    userId: UUID


class AlbumUserResponseDto(BaseModel):
    role: AlbumUserRole
    user: UserResponseDto


class AssetBulkUploadCheckDto(BaseModel):
    assets: List[AssetBulkUploadCheckItem]


class AssetBulkUploadCheckResponseDto(BaseModel):
    results: List[AssetBulkUploadCheckResult]


class AssetFaceResponseDto(BaseModel):
    boundingBoxX1: int
    boundingBoxX2: int
    boundingBoxY1: int
    boundingBoxY2: int
    id: UUID
    imageHeight: int
    imageWidth: int
    person: PersonResponseDto
    sourceType: Optional[SourceType] = None


class AssetFaceUpdateDto(BaseModel):
    data: List[AssetFaceUpdateItem]


class AssetFaceWithoutPersonResponseDto(BaseModel):
    boundingBoxX1: int
    boundingBoxX2: int
    boundingBoxY1: int
    boundingBoxY2: int
    id: UUID
    imageHeight: int
    imageWidth: int
    sourceType: Optional[SourceType] = None


class AssetMediaResponseDto(BaseModel):
    id: str
    status: AssetMediaStatus


class AvatarResponse(BaseModel):
    color: UserAvatarColor


class AvatarUpdate(BaseModel):
    color: Optional[UserAvatarColor] = None


class CreateAlbumDto(BaseModel):
    albumName: str
    albumUsers: Optional[List[AlbumUserCreateDto]] = None
    assetIds: Optional[List[UUID]] = None
    description: Optional[str] = None


class FileReportItemDto(BaseModel):
    checksum: Optional[str] = None
    entityId: UUID
    entityType: PathEntityType
    pathType: PathType
    pathValue: str


class JobCreateDto(BaseModel):
    name: ManualJobName


class JobStatusDto(BaseModel):
    jobCounts: JobCountsDto
    queueStatus: QueueStatusDto


class MemoryCreateDto(BaseModel):
    assetIds: Optional[List[UUID]] = None
    data: OnThisDayDto
    isSaved: Optional[bool] = None
    memoryAt: datetime
    seenAt: Optional[datetime] = None
    type: MemoryType


class PartnerResponseDto(BaseModel):
    avatarColor: UserAvatarColor
    email: str
    id: str
    inTimeline: Optional[bool] = None
    name: str
    profileChangedAt: datetime
    profileImagePath: str


class PeopleResponseDto(BaseModel):
    hasNextPage: Optional[bool] = Field(
        None, description="This property was added in v1.110.0"
    )
    hidden: int
    people: List[PersonResponseDto]
    total: int


class PeopleUpdateDto(BaseModel):
    people: List[PeopleUpdateItem]


class PersonWithFacesResponseDto(BaseModel):
    birthDate: date | None
    faces: List[AssetFaceWithoutPersonResponseDto]
    id: str
    isHidden: bool
    name: str
    thumbnailPath: str
    updatedAt: Optional[datetime] = Field(
        None, description="This property was added in v1.107.0"
    )


class ServerStatsResponseDto(BaseModel):
    photos: int
    usage: int
    usageByUser: List[UsageByUserDto] = Field(
        ...,
        examples=[
            [
                {
                    "photos": 1,
                    "videos": 1,
                    "diskUsageRaw": 2,
                    "usagePhotos": 1,
                    "usageVideos": 1,
                }
            ]
        ],
        title="Array of usage for each user",
    )
    usagePhotos: int
    usageVideos: int
    videos: int


class SharedLinkCreateDto(BaseModel):
    albumId: Optional[UUID] = None
    allowDownload: Optional[bool] = True
    allowUpload: Optional[bool] = None
    assetIds: Optional[List[UUID]] = None
    description: Optional[str] = None
    expiresAt: Optional[datetime] = None
    password: Optional[str] = None
    showMetadata: Optional[bool] = True
    type: SharedLinkType


class SystemConfigFFmpegDto(BaseModel):
    accel: TranscodeHWAccel
    accelDecode: bool
    acceptedAudioCodecs: List[AudioCodec]
    acceptedContainers: List[VideoContainer]
    acceptedVideoCodecs: List[VideoCodec]
    bframes: conint(ge=-1, le=16)
    cqMode: CQMode
    crf: conint(ge=0, le=51)
    gopSize: conint(ge=0)
    maxBitrate: str
    preferredHwDevice: str
    preset: str
    refs: conint(ge=0, le=6)
    targetAudioCodec: AudioCodec
    targetResolution: str
    targetVideoCodec: VideoCodec
    temporalAQ: bool
    threads: conint(ge=0)
    tonemap: ToneMapping
    transcode: TranscodePolicy
    twoPass: bool


class SystemConfigLibraryDto(BaseModel):
    scan: SystemConfigLibraryScanDto
    watch: SystemConfigLibraryWatchDto


class SystemConfigSmtpDto(BaseModel):
    enabled: bool
    from_: str = Field(..., alias="from")
    replyTo: str
    transport: SystemConfigSmtpTransportDto


class UserAdminResponseDto(BaseModel):
    avatarColor: UserAvatarColor
    createdAt: datetime
    deletedAt: datetime
    email: str
    id: str
    isAdmin: bool
    license: UserLicense
    name: str
    oauthId: str
    profileChangedAt: datetime
    profileImagePath: str
    quotaSizeInBytes: int
    quotaUsageInBytes: int
    shouldChangePassword: bool
    status: UserStatus
    storageLabel: str
    updatedAt: datetime


class UserPreferencesResponseDto(BaseModel):
    avatar: AvatarResponse
    download: DownloadResponse
    emailNotifications: EmailNotificationsResponse
    folders: FoldersResponse
    memories: MemoriesResponse
    people: PeopleResponse
    purchase: PurchaseResponse
    ratings: RatingsResponse
    tags: TagsResponse


class UserPreferencesUpdateDto(BaseModel):
    avatar: Optional[AvatarUpdate] = None
    download: Optional[DownloadUpdate] = None
    emailNotifications: Optional[EmailNotificationsUpdate] = None
    folders: Optional[FoldersUpdate] = None
    memories: Optional[MemoriesUpdate] = None
    people: Optional[PeopleUpdate] = None
    purchase: Optional[PurchaseUpdate] = None
    ratings: Optional[RatingsUpdate] = None
    tags: Optional[TagsUpdate] = None


class APIKeyCreateResponseDto(BaseModel):
    apiKey: APIKeyResponseDto
    secret: str


class AddUsersDto(BaseModel):
    albumUsers: List[AlbumUserAddDto] = Field(..., min_length=1)


class AllJobStatusResponseDto(BaseModel):
    backgroundTask: JobStatusDto
    backupDatabase: JobStatusDto
    duplicateDetection: JobStatusDto
    faceDetection: JobStatusDto
    facialRecognition: JobStatusDto
    library: JobStatusDto
    metadataExtraction: JobStatusDto
    migration: JobStatusDto
    notifications: JobStatusDto
    search: JobStatusDto
    sidecar: JobStatusDto
    smartSearch: JobStatusDto
    storageTemplateMigration: JobStatusDto
    thumbnailGeneration: JobStatusDto
    videoConversion: JobStatusDto


class AssetResponseDto(BaseModel):
    checksum: str = Field(..., description="base64 encoded sha1 hash")
    deviceAssetId: str
    deviceId: str
    duplicateId: Optional[str] = None
    duration: str
    exifInfo: Optional[ExifResponseDto] = None
    fileCreatedAt: datetime
    fileModifiedAt: datetime
    hasMetadata: bool
    id: str
    isArchived: bool
    isFavorite: bool
    isOffline: bool
    isTrashed: bool
    libraryId: Optional[str] = Field(
        None, description="This property was deprecated in v1.106.0"
    )
    livePhotoVideoId: Optional[str] = None
    localDateTime: datetime
    originalFileName: str
    originalMimeType: Optional[str] = None
    originalPath: str
    owner: Optional[UserResponseDto] = None
    ownerId: str
    people: Optional[List[PersonWithFacesResponseDto]] = None
    resized: Optional[bool] = Field(
        None, description="This property was deprecated in v1.113.0"
    )
    stack: Optional[AssetStackResponseDto] = None
    tags: Optional[List[TagResponseDto]] = None
    thumbhash: str
    type: AssetTypeEnum
    unassignedFaces: Optional[List[AssetFaceWithoutPersonResponseDto]] = None
    updatedAt: datetime


class DuplicateResponseDto(BaseModel):
    assets: List[AssetResponseDto]
    duplicateId: str


class FileReportDto(BaseModel):
    extras: List[str]
    orphans: List[FileReportItemDto]


class FileReportFixDto(BaseModel):
    items: List[FileReportItemDto]


class MemoryLaneResponseDto(BaseModel):
    assets: List[AssetResponseDto]
    yearsAgo: int


class MemoryResponseDto(BaseModel):
    assets: List[AssetResponseDto]
    createdAt: datetime
    data: OnThisDayDto
    deletedAt: Optional[datetime] = None
    id: str
    isSaved: bool
    memoryAt: datetime
    ownerId: str
    seenAt: Optional[datetime] = None
    type: MemoryType
    updatedAt: datetime


class SearchAssetResponseDto(BaseModel):
    count: int
    facets: List[SearchFacetResponseDto]
    items: List[AssetResponseDto]
    nextPage: str
    total: int


class SearchExploreItem(BaseModel):
    data: AssetResponseDto
    value: str


class SearchExploreResponseDto(BaseModel):
    fieldName: str
    items: List[SearchExploreItem]


class StackResponseDto(BaseModel):
    assets: List[AssetResponseDto]
    id: str
    primaryAssetId: str


class SystemConfigNotificationsDto(BaseModel):
    smtp: SystemConfigSmtpDto


class AlbumResponseDto(BaseModel):
    albumName: str
    albumThumbnailAssetId: str
    albumUsers: List[AlbumUserResponseDto]
    assetCount: int
    assets: List[AssetResponseDto]
    createdAt: datetime
    description: str
    endDate: Optional[datetime] = None
    hasSharedLink: bool
    id: str
    isActivityEnabled: bool
    lastModifiedAssetTimestamp: Optional[datetime] = None
    order: Optional[AssetOrder] = None
    owner: UserResponseDto
    ownerId: str
    shared: bool
    startDate: Optional[datetime] = None
    updatedAt: datetime


class AssetDeltaSyncResponseDto(BaseModel):
    deleted: List[str]
    needsFullSync: bool
    upserted: List[AssetResponseDto]


class SearchAlbumResponseDto(BaseModel):
    count: int
    facets: List[SearchFacetResponseDto]
    items: List[AlbumResponseDto]
    total: int


class SearchResponseDto(BaseModel):
    albums: SearchAlbumResponseDto
    assets: SearchAssetResponseDto


class SharedLinkResponseDto(BaseModel):
    album: Optional[AlbumResponseDto] = None
    allowDownload: bool
    allowUpload: bool
    assets: List[AssetResponseDto]
    createdAt: datetime
    description: str
    expiresAt: datetime
    id: str
    key: str
    password: str
    showMetadata: bool
    token: Optional[str] = None
    type: SharedLinkType
    userId: str


class SystemConfigDto(BaseModel):
    backup: SystemConfigBackupsDto
    ffmpeg: SystemConfigFFmpegDto
    image: SystemConfigImageDto
    job: SystemConfigJobDto
    library: SystemConfigLibraryDto
    logging: SystemConfigLoggingDto
    machineLearning: SystemConfigMachineLearningDto
    map: SystemConfigMapDto
    metadata: SystemConfigMetadataDto
    newVersionCheck: SystemConfigNewVersionCheckDto
    notifications: SystemConfigNotificationsDto
    oauth: SystemConfigOAuthDto
    passwordLogin: SystemConfigPasswordLoginDto
    reverseGeocoding: SystemConfigReverseGeocodingDto
    server: SystemConfigServerDto
    storageTemplate: SystemConfigStorageTemplateDto
    templates: SystemConfigTemplatesDto
    theme: SystemConfigThemeDto
    trash: SystemConfigTrashDto
    user: SystemConfigUserDto
